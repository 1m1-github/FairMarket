#pragma version 8

// b 5
// i
// 32+24+8+16+x+8+16
// 256
// global params
// owner [32 bytes]
// chrony/highroller/subjective importance [3xint: 3*=24 bytes] [owner can change]
// min [int: 8 bytes] [owner can change]
// min precision [2xint: 2*8=16 bytes] [owner can change]
// reputation +/- [2xint: 2*8=16 bytes]
// version [int: 8 bytes]
// description [bytes] [owner can change]
// encryption public key [256 bytes = 3 vars]

// size=32+9*8=104

// size=2*32+5*8+1=105


// bid list = list of txids [boxes]

// reputation list of bidd   ers [boxes]

// api
// create bid [bidder]
// cancel bid [bidder]
// trade [seller] = create bid [bidder]
// add reputation [bidder]
// withdraw [seller]

// create bid
// if 0<min, do not allow 0 lurker
// add box

// cancel bid
// input txid, bidder == txn.Sender
// remove box

// trade
// not with lurker
// add bidder to reputation list
// remove bid
// send fee to treasury in exchange for project coins for bidder and seller

// withdraw
// if amount < locked via bids



// if Txn.ApplicationID == 0:
  txn ApplicationID
  pushint 0
  ==
  bz l0_end
  // then:
    // Handle Create App
    
    // for i in 0:8:
      pushint 0
      store 0 // i
      l1_for:
      load 0 // i
      pushint 8
      ==
      bnz l1_end
      // assert(len(Txn.ApplicationArgs[i]) == 8)
      load 0 // i
      txnas ApplicationArgs
      len
      pushint 8
      ==
      assert
      load 0 // i
      pushint 1
      +
      store 0 // i
      b l1_for
      l1_end: // end
    // bytes a = Txn.Sender [slot 0]
    txn Sender
    store 0 // a
    // a = concat(a, Txn.ApplicationArgs[0])
    load 0 // a
    txna ApplicationArgs 0
    concat
    store 0 // a
    // a = concat(a, Txn.ApplicationArgs[1])
    load 0 // a
    txna ApplicationArgs 1
    concat
    store 0 // a
    // a = concat(a, Txn.ApplicationArgs[2])
    load 0 // a
    txna ApplicationArgs 2
    concat
    store 0 // a
    // a = concat(a, Txn.ApplicationArgs[3])
    load 0 // a
    txna ApplicationArgs 3
    concat
    store 0 // a
    // a = concat(a, Txn.ApplicationArgs[4])
    load 0 // a
    txna ApplicationArgs 4
    concat
    store 0 // a
    // a = concat(a, Txn.ApplicationArgs[5])
    load 0 // a
    txna ApplicationArgs 5
    concat
    store 0 // a
    // a = concat(a, Txn.ApplicationArgs[6])
    load 0 // a
    txna ApplicationArgs 6
    concat
    store 0 // a
    // a = concat(a, Txn.ApplicationArgs[7])
    load 0 // a
    txna ApplicationArgs 7
    concat
    store 0 // a
    // a = concat(a, Txn.ApplicationArgs[8])
    load 0 // a
    txna ApplicationArgs 8
    concat
    store 0 // a
    // app_global_put("a", a)
    pushbytes "a"
    load 0 // a
    app_global_put
    
    // app_global_put("d", Txn.ApplicationArgs[9])
    pushbytes "d"
    txna ApplicationArgs 9
    app_global_put
    
    // app_global_put("e1", Txn.ApplicationArgs[10])
    pushbytes "e1"
    txna ApplicationArgs 10
    app_global_put
    // app_global_put("e2", Txn.ApplicationArgs[11])
    pushbytes "e2"
    txna ApplicationArgs 11
    app_global_put
    // app_global_put("e3", Txn.ApplicationArgs[12])
    pushbytes "e3"
    txna ApplicationArgs 12
    app_global_put
    
    // exit(1)
    pushint 1
    return
  l0_end: // end

// switch Txn.OnCompletion:
txn OnCompletion
pushint 0 // NoOp
==
bnz main
txn OnCompletion
pushint 1 // OptIn
==
bnz opt_in
txn OnCompletion
pushint 2 // CloseOut
==
bnz close_out
txn OnCompletion
pushint 4 // UpdateApplication
==
bnz update_app
txn OnCompletion
pushint 5 // DeleteApplication
==
bnz delete_app
err // unexpected value

// block opt_in
opt_in:
  // Disallow Opt In
  // exit(0)
  pushint 0
  return

// block close_out
close_out:
  // Disallow Closing Out
  // exit(0)
  pushint 0
  return

// block update_app
update_app:
  // Handle Update App
  // Only allow the Creator to update the app
  // assert(Txn.Sender == Global.CreatorAddress)
  txn Sender
  global CreatorAddress
  ==
  assert
  // (for now)
  // exit(1)
  pushint 1
  return

// block delete_app
delete_app:
  // Handle Delete App
  // Only allow the Creator to delete the app
  // assert(Txn.Sender == Global.CreatorAddress)
  txn Sender
  global CreatorAddress
  ==
  assert
  // (for now)
  // exit(1)
  pushint 1
  return

// block main
main:
  
  // assert(Txn.RekeyTo == Global.ZeroAddress)
  txn RekeyTo
  global ZeroAddress
  ==
  assert
  
  // switch Txn.ApplicationArgs[0]:
  txna ApplicationArgs 0
  pushbytes "update_params"
  ==
  bnz update_params
  txna ApplicationArgs 0
  pushbytes "create_bid"
  ==
  bnz create_bid
  txna ApplicationArgs 0
  pushbytes "cancel_bid"
  ==
  bnz cancel_bid
  txna ApplicationArgs 0
  pushbytes "add_reputation"
  ==
  bnz add_reputation
  txna ApplicationArgs 0
  pushbytes "withdraw"
  ==
  bnz withdraw
  txna ApplicationArgs 0
  pushbytes "add_data"
  ==
  bnz add_data
  err // unexpected value

// block update_params
update_params:
  // exit(1)
  pushint 1
  return

// block create_bid
create_bid:
  
  // indices
  // int fx_call_ix = 0 [slot 1]
  pushint 0
  store 1 // fx_call_ix
  // int algo_send_ix = 1 [slot 2]
  pushint 1
  store 2 // algo_send_ix
  // int app_call_ix = 2 [slot 3]
  pushint 2
  store 3 // app_call_ix
  // int asset_send_ix = 3 [slot 4]
  pushint 3
  store 4 // asset_send_ix
  // int e = Global.GroupSize-1
  
  // check_create_bid(asset_send_ix, fx_call_ix, app_call_ix, algo_send_ix)
  load 4 // asset_send_ix
  load 1 // fx_call_ix
  load 3 // app_call_ix
  load 2 // algo_send_ix
  callsub __func__check_create_bid
  
  // opt_in(Gtxn[asset_send_ix].XferAsset)
  load 4 // asset_send_ix
  gtxns XferAsset
  callsub __func__opt_in
  
  // box_content
  // parent
  // log(Txn.ApplicationArgs[1])
  // log(itob(len(Txn.ApplicationArgs[1])))
  // exit(1)
  // assert(len(Txn.ApplicationArgs[1]) == 32)
  txna ApplicationArgs 1
  len
  pushint 32
  ==
  assert
  // bytes box_content = Txn.ApplicationArgs[1] [slot 5]
  txna ApplicationArgs 1
  store 5 // box_content
  // owner
  // box_content = concat(box_content, Txn.Sender)
  load 5 // box_content
  txn Sender
  concat
  store 5 // box_content
  // fairmarket
  // assert(len(Txn.ApplicationArgs[2]) == 8)
  txna ApplicationArgs 2
  len
  pushint 8
  ==
  assert
  // box_content = concat(box_content, Txn.ApplicationArgs[2])
  load 5 // box_content
  txna ApplicationArgs 2
  concat
  store 5 // box_content
  // currency_id
  // box_content = concat(box_content, itob(Gtxn[asset_send_ix].XferAsset))
  load 5 // box_content
  load 4 // asset_send_ix
  gtxns XferAsset
  itob
  concat
  store 5 // box_content
  // currency_quantity
  // box_content = concat(box_content, itob(Gtxn[asset_send_ix].AssetAmount))
  load 5 // box_content
  load 4 // asset_send_ix
  gtxns AssetAmount
  itob
  concat
  store 5 // box_content
  // bytes fx = Gtxn[fx_call_ix].LastLog [slot 6]
  load 1 // fx_call_ix
  gtxns LastLog
  store 6 // fx
  // box_content = concat(box_content, fx)
  load 5 // box_content
  load 6 // fx
  concat
  store 5 // box_content
  // bytes type = calc_type(Gtxn[asset_send_ix].AssetAmount, fx) [slot 7]
  load 4 // asset_send_ix
  gtxns AssetAmount
  load 6 // fx
  callsub __func__calc_type
  store 7 // type
  // box_content = concat(box_content, type)
  load 5 // box_content
  load 7 // type
  concat
  store 5 // box_content
  // BidWithoutNote bidWithoutNote = box_content [slot 8]
  load 5 // box_content
  store 8 // bidWithoutNote
  
  // int e = Global.GroupSize-1 [slot 9]
  global GroupSize
  pushint 1
  -
  store 9 // e
  // for i in 0:e:
    pushint 0
    store 10 // i
    l2_for:
    load 10 // i
    load 9 // e
    ==
    bnz l2_end
    // box_content = concat(box_content, Gtxn[i].Note)
    load 5 // box_content
    load 10 // i
    gtxns Note
    concat
    store 5 // box_content
    load 10 // i
    pushint 1
    +
    store 10 // i
    b l2_for
    l2_end: // end
  
  // bytes box_name = Txn.ApplicationArgs[3] [slot 10]
  txna ApplicationArgs 3
  store 10 // box_name
  // assert(len(box_name) == 32)
  load 10 // box_name
  len
  pushint 32
  ==
  assert
  // int box_existed = box_create(box_name, len(box_content)) [slot 11]
  load 10 // box_name
  load 5 // box_content
  len
  box_create
  store 11 // box_existed
  // assert(box_existed == 1)
  load 11 // box_existed
  pushint 1
  ==
  assert
  // box_replace(box_name, 0, box_content)
  load 10 // box_name
  pushint 0
  load 5 // box_content
  box_replace
  
  // exit(1)
  pushint 1
  return
  

// block cancel_bid
cancel_bid:
  
  // bytes box_name = Txn.ApplicationArgs[1] [slot 1]
  txna ApplicationArgs 1
  store 1 // box_name
  // int box_exists [slot 2]
  // bytes box_contents [slot 3]
  // box_exists, box_contents = box_get(box_name)
  load 1 // box_name
  box_get
  store 2 // box_exists
  store 3 // box_contents
  // assert(box_exists == 1)
  load 2 // box_exists
  pushint 1
  ==
  assert
  
  // BidWithoutNote bid = substring(0, 105, box_contents) [slot 4]
  load 3 // box_contents
  substring 0 105
  store 4 // bid
  
  // assert(Txn.Sender == bid.owner)
  txn Sender
  load 4 // bid
  extract 32 32 // owner
  ==
  assert
  
  // inner_txn:
  itxn_begin
    // TypeEnum: Axfer
    pushint 4 // Axfer
    itxn_field TypeEnum
    // Sender: Global.CurrentApplicationAddress
    global CurrentApplicationAddress
    itxn_field Sender
    // AssetReceiver: bid.owner
    load 4 // bid
    extract 32 32 // owner
    itxn_field AssetReceiver
    // AssetAmount: bid.currency_quantity
    load 4 // bid
    pushint 80
    extract_uint64 // currency_quantity
    itxn_field AssetAmount
    // XferAsset: bid.currency_id
    load 4 // bid
    pushint 72
    extract_uint64 // currency_id
    itxn_field XferAsset
    // Fee: 0
    pushint 0
    itxn_field Fee
  itxn_submit
  // end inner_txn
  
  // _ = box_del(box_name)
  load 1 // box_name
  box_del
  pop // discarding value for _
  
  // exit(1)
  pushint 1
  return

// block add_reputation
add_reputation:
  // exit(1)
  pushint 1
  return
// block withdraw
withdraw:
  // exit(1)
  pushint 1
  return
// block add_data
add_data:
  // exit(1)
  pushint 1
  return

// func abi_return(result: bytes):
__func__abi_return:
store 12 // result
// log(concat("\x15\x1f\x7c\x75", result))
// log(result)
load 12 // result
log
// return
retsub

// func abi_encode_uint64(value: int) bytes:
__func__abi_encode_uint64:
store 13 // value
// return itob(value)
load 13 // value
itob
retsub

// TODO assert input sizes, choose m appropriately
// func calc_type(asset_amount: int, fx: bytes) bytes:
__func__calc_type:
store 14 // fx
store 15 // asset_amount

// if fx == "SUBJECTIVE":
  load 14 // fx
  pushbytes "SUBJECTIVE"
  ==
  bz l3_end
  // then:
    // return "S"
    pushbytes "S"
    retsub
  l3_end: // end

// int m = 10000 [slot 16]
pushint 10000
store 16 // m

// int fx_n = extract_uint64(fx, 0) [slot 17]
load 14 // fx
pushint 0
extract_uint64
store 17 // fx_n
// int fx_d = extract_uint64(fx, 8) [slot 18]
load 14 // fx
pushint 8
extract_uint64
store 18 // fx_d

// Params p = app_global_get("a") [slot 19]
pushbytes "a"
app_global_get
store 19 // p

// int currency_quantity_after_fx = (m * (asset_amount * fx_n)) / fx_d [slot 20]
load 16 // m
load 15 // asset_amount
load 17 // fx_n
*
*
load 18 // fx_d
/
store 20 // currency_quantity_after_fx
// int chrony_upper_bound = p.min * (m + ((m * p.min_precision_n) / p.min_precision_d)) [slot 21]
load 19 // p
pushint 56
extract_uint64 // min
load 16 // m
load 16 // m
load 19 // p
pushint 64
extract_uint64 // min_precision_n
*
load 19 // p
pushint 72
extract_uint64 // min_precision_d
/
+
*
store 21 // chrony_upper_bound
// int chrony_lower_bound = p.min * (m - ((m * p.min_precision_n) / p.min_precision_d)) [slot 22]
load 19 // p
pushint 56
extract_uint64 // min
load 16 // m
load 16 // m
load 19 // p
pushint 64
extract_uint64 // min_precision_n
*
load 19 // p
pushint 72
extract_uint64 // min_precision_d
/
-
*
store 22 // chrony_lower_bound

// if currency_quantity_after_fx == 0:
  load 20 // currency_quantity_after_fx
  pushint 0
  ==
  bz l4_elif_0
  // then:
    // if chrony_lower_bound == 0:
      load 22 // chrony_lower_bound
      pushint 0
      ==
      bz l5_else
      // then:
        // return "L"
        pushbytes "L"
        retsub
      b l5_end
      l5_else:
      // else:
        // 0 lurker with 0<min is a spammer
        // exit(0)
        pushint 0
        return
      l5_end: // end
  b l4_end
  l4_elif_0:
  // elif currency_quantity_after_fx < chrony_lower_bound:
  load 20 // currency_quantity_after_fx
  load 22 // chrony_lower_bound
  <
  bz l4_elif_1
    // return "L"
    pushbytes "L"
    retsub
  b l4_end
  l4_elif_1:
  // elif chrony_upper_bound < currency_quantity_after_fx:
  load 21 // chrony_upper_bound
  load 20 // currency_quantity_after_fx
  <
  bz l4_else
    // return "H"
    pushbytes "H"
    retsub
  b l4_end
  l4_else:
  // else:
    // return "C"
    pushbytes "C"
    retsub
  l4_end: // end

// should never reach here
// exit(0)
pushint 0
return
// return "X"
pushbytes "X"
retsub

// func opt_in(asset_id: int):
__func__opt_in:
store 23 // asset_id
// int is_opted_in [slot 24]
// is_opted_in, _ = asset_holding_get(AssetBalance, Global.CurrentApplicationAddress, asset_id)
global CurrentApplicationAddress
load 23 // asset_id
asset_holding_get AssetBalance
store 24 // is_opted_in
pop // discarding value for _
// if is_opted_in == 0:
  load 24 // is_opted_in
  pushint 0
  ==
  bz l6_end
  // then:
    // inner_txn:
    itxn_begin
      // TypeEnum: Axfer
      pushint 4 // Axfer
      itxn_field TypeEnum
      // Sender: Global.CurrentApplicationAddress
      global CurrentApplicationAddress
      itxn_field Sender
      // AssetReceiver: Global.CurrentApplicationAddress
      global CurrentApplicationAddress
      itxn_field AssetReceiver
      // AssetAmount: 0
      pushint 0
      itxn_field AssetAmount
      // XferAsset: asset_id
      load 23 // asset_id
      itxn_field XferAsset
      // Fee: 0
      pushint 0
      itxn_field Fee
    itxn_submit
    // end inner_txn
  l6_end: // end
// return
retsub

// func check_create_bid(asset_send_ix: int, fx_call_ix: int, app_call_ix: int, algo_send_ix: int):
__func__check_create_bid:
store 25 // algo_send_ix
store 26 // app_call_ix
store 27 // fx_call_ix
store 28 // asset_send_ix
// assert(Gtxn[asset_send_ix].TypeEnum == Axfer)
load 28 // asset_send_ix
gtxns TypeEnum
pushint 4 // Axfer
==
assert
// assert(Gtxn[asset_send_ix].AssetReceiver == Global.CurrentApplicationAddress)
load 28 // asset_send_ix
gtxns AssetReceiver
global CurrentApplicationAddress
==
assert
// assert(Gtxn[fx_call_ix].TypeEnum == Appl)
load 27 // fx_call_ix
gtxns TypeEnum
pushint 6 // Appl
==
assert
// assert(Gtxn[fx_call_ix].Sender == Gtxn[asset_send_ix].Sender)
load 27 // fx_call_ix
gtxns Sender
load 28 // asset_send_ix
gtxns Sender
==
assert
// assert(Gtxn[fx_call_ix].ApplicationID == FX_APP)
load 27 // fx_call_ix
gtxns ApplicationID
pushint 178969021 // FX_APP
==
assert
// assert(Gtxn[asset_send_ix].XferAsset == Gtxn[fx_call_ix].Assets[0])
load 28 // asset_send_ix
gtxns XferAsset
load 27 // fx_call_ix
gtxnsa Assets 0
==
assert
// assert(Txn.GroupIndex == app_call_ix)
txn GroupIndex
load 26 // app_call_ix
==
assert
// assert(Txn.Sender == Gtxn[asset_send_ix].Sender)
txn Sender
load 28 // asset_send_ix
gtxns Sender
==
assert
// assert(Gtxn[algo_send_ix].TypeEnum == Pay)
load 25 // algo_send_ix
gtxns TypeEnum
pushint 1 // Pay
==
assert
// assert(Gtxn[algo_send_ix].Sender == Gtxn[asset_send_ix].Sender)
load 25 // algo_send_ix
gtxns Sender
load 28 // asset_send_ix
gtxns Sender
==
assert
// assert(Gtxn[algo_send_ix].Receiver == Global.CurrentApplicationAddress)
load 25 // algo_send_ix
gtxns Receiver
global CurrentApplicationAddress
==
assert
// int e = Global.GroupSize - 1 [slot 29]
global GroupSize
pushint 1
-
store 29 // e
// for i in 4:e:
  pushint 4
  store 30 // i
  l7_for:
  load 30 // i
  load 29 // e
  ==
  bnz l7_end
  // assert(Gtxn[i].TypeEnum == Appl)
  load 30 // i
  gtxns TypeEnum
  pushint 6 // Appl
  ==
  assert
  load 30 // i
  pushint 1
  +
  store 30 // i
  b l7_for
  l7_end: // end
// return
retsub
