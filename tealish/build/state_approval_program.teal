#pragma version 8

// A creates bid for B with currency and data attached
// A can cancel and get currency back before
// B trades to receive currency and send receipt to A
// receipt contains data

// global
// version:int
// min_precision_n: int
// min_precision_d: int

// central smart contract
// default params
// box with user name contains own params (updatable)
// box with hash(ABNoteCurrency) is bid

// size=4*8+32+256=320

// size=2*32+4*8+1=97


// api
// create bid [A]
// cancel bid [A]
// trade [B]
// update params

// create bid
// if 0<min, do not allow 0 lurker
// add box

// cancel bid
// remove bid
// send currency back

// trade
// not with lurker
// remove bid

// if Txn.ApplicationID == 0:
  txn ApplicationID
  pushint 0
  ==
  bz l0_end
  // then:
    // Handle Create App
    
    // version
    // app_global_put("v", 1)
    pushbytes "v"
    pushint 1
    app_global_put
    
    // min_precision_n
    // app_global_put("mn", 1)
    pushbytes "mn"
    pushint 1
    app_global_put
    
    // min_precision_d
    // app_global_put("md", 10)
    pushbytes "md"
    pushint 10
    app_global_put
    
    // exit(1)
    pushint 1
    return
  l0_end: // end

// switch Txn.OnCompletion:
txn OnCompletion
pushint 0 // NoOp
==
bnz main
txn OnCompletion
pushint 1 // OptIn
==
bnz opt_in
txn OnCompletion
pushint 2 // CloseOut
==
bnz close_out
txn OnCompletion
pushint 4 // UpdateApplication
==
bnz update_app
txn OnCompletion
pushint 5 // DeleteApplication
==
bnz delete_app
err // unexpected value

// block opt_in
opt_in:
  // Disallow Opt In
  // exit(0)
  pushint 0
  return

// block close_out
close_out:
  // Disallow Closing Out
  // exit(0)
  pushint 0
  return

// block update_app
update_app:
  // Handle Update App
  // Only allow the Creator to update the app
  // assert(Txn.Sender == Global.CreatorAddress)
  txn Sender
  global CreatorAddress
  ==
  assert
  // (for now)
  // exit(1)
  pushint 1
  return

// block delete_app
delete_app:
  // Disallow Delete App
  // exit(0)
  pushint 0
  return

// block main
main:
  // safety
  // int e = Global.GroupSize-1 [slot 0]
  global GroupSize
  pushint 1
  -
  store 0 // e
  // for i in 0:e:
    pushint 0
    store 1 // i
    l1_for:
    load 1 // i
    load 0 // e
    ==
    bnz l1_end
    // assert(Gtxn[i].RekeyTo == Global.ZeroAddress)
    load 1 // i
    gtxns RekeyTo
    global ZeroAddress
    ==
    assert
    load 1 // i
    pushint 1
    +
    store 1 // i
    b l1_for
    l1_end: // end
  
  // main switch
  // switch Txn.ApplicationArgs[0]:
  txna ApplicationArgs 0
  pushbytes "create_bid"
  ==
  bnz create_bid
  txna ApplicationArgs 0
  pushbytes "cancel_bid"
  ==
  bnz cancel_bid
  txna ApplicationArgs 0
  pushbytes "trade"
  ==
  bnz trade
  txna ApplicationArgs 0
  pushbytes "update_params"
  ==
  bnz update_params
  txna ApplicationArgs 0
  pushbytes "add_data"
  ==
  bnz add_data
  err // unexpected value

// block create_bid
create_bid:
  // indices
  // int fx_call_ix = 0 [slot 0]
  pushint 0
  store 0 // fx_call_ix
  // int algo_send_ix = 1 [slot 1]
  pushint 1
  store 1 // algo_send_ix
  // int app_call_ix = 2 [slot 2]
  pushint 2
  store 2 // app_call_ix
  // int asset_send_ix = 3 [slot 3]
  pushint 3
  store 3 // asset_send_ix
  
  // check_create_bid(asset_send_ix, fx_call_ix, app_call_ix, algo_send_ix)
  
  // opt_in(Gtxn[asset_send_ix].XferAsset)
  load 3 // asset_send_ix
  gtxns XferAsset
  callsub __func__opt_in
  
  // box_content
  // A, b = B
  // bytes b = extract(0, 32, Txn.Note) [slot 4]
  txn Note
  extract 0 32
  store 4 // b
  // bytes bid = concat(Txn.Sender, b) [slot 5]
  txn Sender
  load 4 // b
  concat
  store 5 // bid
  // currency_id
  // bytes currency_id_bytes = itob(Gtxn[asset_send_ix].XferAsset) [slot 6]
  load 3 // asset_send_ix
  gtxns XferAsset
  itob
  store 6 // currency_id_bytes
  // bid = concat(bid, currency_id_bytes)
  load 5 // bid
  load 6 // currency_id_bytes
  concat
  store 5 // bid
  // currency_amount
  // bytes currency_amount_bytes = itob(Gtxn[asset_send_ix].AssetAmount) [slot 7]
  load 3 // asset_send_ix
  gtxns AssetAmount
  itob
  store 7 // currency_amount_bytes
  // bid = concat(bid, currency_amount_bytes)
  load 5 // bid
  load 7 // currency_amount_bytes
  concat
  store 5 // bid
  // fx
  // bytes fx = Gtxn[fx_call_ix].LastLog [slot 8]
  load 0 // fx_call_ix
  gtxns LastLog
  store 8 // fx
  // bid = concat(bid, fx)
  load 5 // bid
  load 8 // fx
  concat
  store 5 // bid
  // type
  // bytes type = calc_type(Gtxn[asset_send_ix].AssetAmount, fx) [slot 9]
  load 3 // asset_send_ix
  gtxns AssetAmount
  load 8 // fx
  callsub __func__calc_type
  store 9 // type
  // bid = concat(bid, type)
  load 5 // bid
  load 9 // type
  concat
  store 5 // bid
  
  // note
  // int s = Txn.GroupIndex + 1 [slot 10]
  txn GroupIndex
  pushint 1
  +
  store 10 // s
  // int e = Global.GroupSize - 1 [slot 11]
  global GroupSize
  pushint 1
  -
  store 11 // e
  // first 32 bytes of Txn.Note is B
  // bytes note = extract(33, 0, Txn.Note) [slot 12]
  txn Note
  extract 33 0
  store 12 // note
  // for i in s:e:
    load 10 // s
    store 13 // i
    l2_for:
    load 13 // i
    load 11 // e
    ==
    bnz l2_end
    // if Gtxn[i].ApplicationArgs[0] == "add_data":
      load 13 // i
      gtxnsa ApplicationArgs 0
      pushbytes "add_data"
      ==
      bz l3_end
      // then:
        // note = concat(note, Gtxn[i].Note)
        load 12 // note
        load 13 // i
        gtxns Note
        concat
        store 12 // note
      l3_end: // end
    load 13 // i
    pushint 1
    +
    store 13 // i
    b l2_for
    l2_end: // end
  // bid = concat(bid, note)
  load 5 // bid
  load 12 // note
  concat
  store 5 // bid
  
  // calc bid_id
  // BID_ID = hash($A$B$CURRENCY_ID$CURRENCY_AMOUNT$NOTE)
  // bytes bid_id_prehash [slot 13]
  // bid_id_prehash = concat(Txn.Sender, b)
  txn Sender
  load 4 // b
  concat
  store 13 // bid_id_prehash
  // bid_id_prehash = concat(bid_id_prehash, currency_id_bytes)
  load 13 // bid_id_prehash
  load 6 // currency_id_bytes
  concat
  store 13 // bid_id_prehash
  // bid_id_prehash = concat(bid_id_prehash, currency_amount_bytes)
  load 13 // bid_id_prehash
  load 7 // currency_amount_bytes
  concat
  store 13 // bid_id_prehash
  // bid_id_prehash = concat(bid_id_prehash, note)
  load 13 // bid_id_prehash
  load 12 // note
  concat
  store 13 // bid_id_prehash
  // bytes bid_id = sha512_256(bid_id_prehash) [slot 14]
  load 13 // bid_id_prehash
  sha512_256
  store 14 // bid_id
  
  // create box
  // int box_existed = box_create(bid_id, len(bid)) [slot 15]
  load 14 // bid_id
  load 5 // bid
  len
  box_create
  store 15 // box_existed
  // assert(box_existed == 1)
  load 15 // box_existed
  pushint 1
  ==
  assert
  // box_replace(bid_id, 0, bid)
  load 14 // bid_id
  pushint 0
  load 5 // bid
  box_replace
  
  // exit(1)
  pushint 1
  return

// block cancel_bid
cancel_bid:
  // bytes bid_id = Txn.ApplicationArgs[1] [slot 0]
  txna ApplicationArgs 1
  store 0 // bid_id
  // int bid_exists [slot 1]
  // bytes bid_contents [slot 2]
  // bid_exists, bid_contents = box_get(bid_id)
  load 0 // bid_id
  box_get
  store 1 // bid_exists
  store 2 // bid_contents
  // assert(bid_exists == 1)
  load 1 // bid_exists
  pushint 1
  ==
  assert
  
  // BidWithoutNote bid = extract(0, BIDWITHOUTNOTESIZE, bid_contents) [slot 3]
  load 2 // bid_contents
  extract 0 BIDWITHOUTNOTESIZE
  store 3 // bid
  
  // only A can cancel
  // assert(Txn.Sender == bid.a)
  txn Sender
  load 3 // bid
  extract 0 32 // a
  ==
  assert
  
  // inner_txn:
  itxn_begin
    // TypeEnum: Axfer
    pushint 4 // Axfer
    itxn_field TypeEnum
    // AssetReceiver: bid.a
    load 3 // bid
    extract 0 32 // a
    itxn_field AssetReceiver
    // AssetAmount: bid.currency_amount
    load 3 // bid
    pushint 72
    extract_uint64 // currency_amount
    itxn_field AssetAmount
    // XferAsset: bid.currency_id
    load 3 // bid
    pushint 64
    extract_uint64 // currency_id
    itxn_field XferAsset
    // Fee: 0
    pushint 0
    itxn_field Fee
  itxn_submit
  // end inner_txn
  
  // # # opt-out if no balance? TODO (e.g. return subj currency reserve)
  // # int currency_balance
  // # currency_balance, _ = asset_holding_get(AssetBalance, 0, bid.currency_id)
  // # if currency_balance == 0:
  // #     inner_txn:
  // #         TypeEnum: Axfer
  // #         Sender: Global.CurrentApplicationAddress
  // #         AssetReceiver: bid.owner
  // #         AssetAmount: bid.currency_quantity
  // #         XferAsset: bid.currency_id
  // #         Fee: 0
  // #     end
  // # end
  
  // _ = box_del(bid_id)
  load 0 // bid_id
  box_del
  pop // discarding value for _
  
  // exit(1)
  pushint 1
  return

// block trade
trade:
  // bytes bid_id = Txn.ApplicationArgs[1] [slot 0]
  txna ApplicationArgs 1
  store 0 // bid_id
  // int bid_exists [slot 1]
  // bytes bid_contents [slot 2]
  // bid_exists, bid_contents = box_get(bid_id)
  load 0 // bid_id
  box_get
  store 1 // bid_exists
  store 2 // bid_contents
  // assert(bid_exists == 1)
  load 1 // bid_exists
  pushint 1
  ==
  assert
  
  // BidWithoutNote bid = extract(0, BIDWITHOUTNOTESIZE, bid_contents) [slot 3]
  load 2 // bid_contents
  extract 0 BIDWITHOUTNOTESIZE
  store 3 // bid
  
  // assert(Txn.Sender == bid.b)
  txn Sender
  load 3 // bid
  extract 32 32 // b
  ==
  assert
  
  // Params p = app_global_get("a")
  
  // # send currency to owner
  // int currency_amount_for_b = bid.currency_amount [slot 4]
  load 3 // bid
  pushint 72
  extract_uint64 // currency_amount
  store 4 // currency_amount_for_b
  // inner_txn:
  itxn_begin
    // TypeEnum: Axfer
    pushint 4 // Axfer
    itxn_field TypeEnum
    // AssetReceiver: bid.b
    load 3 // bid
    extract 32 32 // b
    itxn_field AssetReceiver
    // AssetAmount: currency_amount_for_b
    load 4 // currency_amount_for_b
    itxn_field AssetAmount
    // XferAsset: bid.currency_id
    load 3 // bid
    pushint 64
    extract_uint64 // currency_id
    itxn_field XferAsset
    // Fee: 1000
    pushint 1000
    itxn_field Fee
  itxn_submit
  // end inner_txn
  
  // note
  // int s = Txn.GroupIndex + 1 [slot 5]
  txn GroupIndex
  pushint 1
  +
  store 5 // s
  // int e = Global.GroupSize - 1 [slot 6]
  global GroupSize
  pushint 1
  -
  store 6 // e
  // bytes note = Txn.Note [slot 7]
  txn Note
  store 7 // note
  // for i in s:e:
    load 5 // s
    store 8 // i
    l4_for:
    load 8 // i
    load 6 // e
    ==
    bnz l4_end
    // if Gtxn[i].ApplicationArgs[0] == "add_data":
      load 8 // i
      gtxnsa ApplicationArgs 0
      pushbytes "add_data"
      ==
      bz l5_end
      // then:
        // note = concat(note, Gtxn[i].Note)
        load 7 // note
        load 8 // i
        gtxns Note
        concat
        store 7 // note
      l5_end: // end
    load 8 // i
    pushint 1
    +
    store 8 // i
    b l4_for
    l4_end: // end
  
  // TODO need multiple if note large
  // inner_txn:
  itxn_begin
    // TypeEnum: Pay
    pushint 1 // Pay
    itxn_field TypeEnum
    // Receiver: bid.b
    load 3 // bid
    extract 32 32 // b
    itxn_field Receiver
    // Amount: 0
    pushint 0
    itxn_field Amount
    // Note: note
    load 7 // note
    itxn_field Note
    // Fee: 1000
    pushint 1000
    itxn_field Fee
  itxn_submit
  // end inner_txn
  
  // _ = box_del(bid_id)
  load 0 // bid_id
  box_del
  pop // discarding value for _
  
  // exit(1)
  pushint 1
  return

// block update_params
update_params:
  // exit(1)
  pushint 1
  return

// block add_data
add_data:
  // exit(1)
  pushint 1
  return



// TODO assert input sizes, choose m appropriately
// func calc_type(b: bytes, asset_amount: int, fx: bytes) bytes:
__func__calc_type:
store 16 // fx
store 17 // asset_amount
store 18 // b
// int fx_d = extract_uint64(fx, 8) [slot 19]
load 16 // fx
pushint 8
extract_uint64
store 19 // fx_d
// if fx_d == 0:
  load 19 // fx_d
  pushint 0
  ==
  bz l6_end
  // then:
    // return "S"
    pushbytes "S"
    retsub
  l6_end: // end
// int fx_n = extract_uint64(fx, 0) [slot 20]
load 16 // fx
pushint 0
extract_uint64
store 20 // fx_n

// int m = 10000 [slot 21]
pushint 10000
store 21 // m

// Params p = get_params(b) [slot 22]
load 18 // b
callsub __func__get_params
store 22 // p

// int min_precision_n = app_global_get("mn") [slot 23]
pushbytes "mn"
app_global_get
store 23 // min_precision_n
// int min_precision_d = app_global_get("md") [slot 24]
pushbytes "md"
app_global_get
store 24 // min_precision_d

// int currency_quantity_after_fx = (m * (asset_amount * fx_n)) / fx_d [slot 25]
load 21 // m
load 17 // asset_amount
load 20 // fx_n
*
*
load 19 // fx_d
/
store 25 // currency_quantity_after_fx
// int chrony_upper_bound = p.min * (m + ((m * min_precision_n) / min_precision_d)) [slot 26]
load 22 // p
pushint 24
extract_uint64 // min
load 21 // m
load 21 // m
load 23 // min_precision_n
*
load 24 // min_precision_d
/
+
*
store 26 // chrony_upper_bound
// int chrony_lower_bound = p.min * (m - ((m * min_precision_n) / min_precision_d)) [slot 27]
load 22 // p
pushint 24
extract_uint64 // min
load 21 // m
load 21 // m
load 23 // min_precision_n
*
load 24 // min_precision_d
/
-
*
store 27 // chrony_lower_bound

// if currency_quantity_after_fx == 0:
  load 25 // currency_quantity_after_fx
  pushint 0
  ==
  bz l7_elif_0
  // then:
    // if chrony_lower_bound == 0:
      load 27 // chrony_lower_bound
      pushint 0
      ==
      bz l8_else
      // then:
        // return "L"
        pushbytes "L"
        retsub
      b l8_end
      l8_else:
      // else:
        // 0 lurker with 0<min is a spammer
        // exit(0)
        pushint 0
        return
      l8_end: // end
  b l7_end
  l7_elif_0:
  // elif currency_quantity_after_fx < chrony_lower_bound:
  load 25 // currency_quantity_after_fx
  load 27 // chrony_lower_bound
  <
  bz l7_elif_1
    // return "L"
    pushbytes "L"
    retsub
  b l7_end
  l7_elif_1:
  // elif chrony_upper_bound < currency_quantity_after_fx:
  load 26 // chrony_upper_bound
  load 25 // currency_quantity_after_fx
  <
  bz l7_else
    // return "H"
    pushbytes "H"
    retsub
  b l7_end
  l7_else:
  // else:
    // return "C"
    pushbytes "C"
    retsub
  l7_end: // end

// should never reach here
// exit(0)
pushint 0
return
// return "X"
pushbytes "X"
retsub

// func opt_in(asset_id: int):
__func__opt_in:
store 28 // asset_id
// int is_opted_in [slot 29]
// is_opted_in, _ = asset_holding_get(AssetBalance, Global.CurrentApplicationAddress, asset_id)
global CurrentApplicationAddress
load 28 // asset_id
asset_holding_get AssetBalance
store 29 // is_opted_in
pop // discarding value for _
// if is_opted_in == 0:
  load 29 // is_opted_in
  pushint 0
  ==
  bz l9_end
  // then:
    // inner_txn:
    itxn_begin
      // TypeEnum: Axfer
      pushint 4 // Axfer
      itxn_field TypeEnum
      // Sender: Global.CurrentApplicationAddress
      global CurrentApplicationAddress
      itxn_field Sender
      // AssetReceiver: Global.CurrentApplicationAddress
      global CurrentApplicationAddress
      itxn_field AssetReceiver
      // AssetAmount: 0
      pushint 0
      itxn_field AssetAmount
      // XferAsset: asset_id
      load 28 // asset_id
      itxn_field XferAsset
      // Fee: 0
      pushint 0
      itxn_field Fee
    itxn_submit
    // end inner_txn
  l9_end: // end
// return
retsub

// func check_create_bid(asset_send_ix: int, fx_call_ix: int, app_call_ix: int, algo_send_ix: int):
//     assert(Gtxn[asset_send_ix].TypeEnum == Axfer)
//     assert(Gtxn[asset_send_ix].AssetReceiver == Global.CurrentApplicationAddress)
//     assert(Gtxn[fx_call_ix].TypeEnum == Appl)
//     assert(Gtxn[fx_call_ix].Sender == Gtxn[asset_send_ix].Sender)
//     assert(Gtxn[fx_call_ix].ApplicationID == FX_APP)
//     assert(Gtxn[asset_send_ix].XferAsset == Gtxn[fx_call_ix].Assets[0])
//     assert(Txn.GroupIndex == app_call_ix)
//     assert(Txn.Sender == Gtxn[asset_send_ix].Sender)
//     assert(Gtxn[algo_send_ix].TypeEnum == Pay)
//     assert(Gtxn[algo_send_ix].Sender == Gtxn[asset_send_ix].Sender)
//     assert(Gtxn[algo_send_ix].Receiver == Global.CurrentApplicationAddress)
//     int e = Global.GroupSize - 1
//     for i in 4:e:
//         assert(Gtxn[i].TypeEnum == Appl)
//     end
//     return
// end

// func get_params(b: bytes) bytes:
__func__get_params:
store 30 // b
// bytes p [slot 31]
// int p_exists [slot 32]
// p_exists, p = box_get(b)
load 30 // b
box_get
store 32 // p_exists
store 31 // p
// if p_exists == 1:
  load 32 // p_exists
  pushint 1
  ==
  bz l10_end
  // then:
    // return p
    load 31 // p
    retsub
  l10_end: // end
// return "1111"
pushbytes "1111"
retsub
